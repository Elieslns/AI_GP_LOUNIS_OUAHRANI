\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{titlesec}
\usepackage{hyperref}

\geometry{hmargin=2.5cm,vmargin=2.5cm}

\title{\textbf{Rapport de Projet d'IA : Awalé}}
\author{LOUNIS Elies \and OUAHRANI KHALDI Sofiane}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}
Ce rapport présente l'architecture et les choix algorithmiques de notre IA conçu pour jouer à une variante de l'Awalé (16 trous, graines colorées). L'objectif était de développer une IA performante capable de battre les bots des autres groupes dans un temps de réflexion limité (2 secondes par coup).

\section{Fonction d'Évaluation}
La fonction d'évaluation est le cœur de notre IA. Elle combine 8 heuristiques distinctes pour estimer la qualité d'une position.

\subsection{Heuristiques Principales}

\subsubsection{1. Différence de Score}
Critère principal. Nous calculons la différence de score pondérée selon le stade de la partie (poids de 100 à 200). En fin de partie, ce poids augmente pour forcer la victoire.

\subsubsection{2. Contrôle du Plateau (Défense)}
Nous valorisons le nombre de graines dans notre camp ($+10$ par graine de différence). Cela permet de retarder la famine et de conserver du matériel ("munitions") pour de futures attaques.

\subsubsection{3. Mobilité}
Nous calculons la différence entre notre nombre de coups légaux et celui de l'adversaire. Avoir plus d'options force souvent l'adversaire à réagir plutôt qu'à agir, et évite les situations de blocage ($Zugzwang$).

\subsubsection{4. Sécurité (Vulnérabilité)}
Un trou est "vulnérable" s'il contient 1 ou 2 graines (prenable au prochain coup). Nous appliquons une pénalité pour chaque trou vulnérable dans notre camp et un bonus pour ceux chez l'adversaire.

\subsubsection{5. Potentiel de Capture (Horizon 1)}
L'IA regarde "un coup plus loin" pour voir si une capture immédiate est possible. C'est une heuristique gloutonne qui guide la recherche tactique.

\subsubsection{6. Trous "Chargés" (Stratégie Long Terme)}
Nous comptons le nombre de trous contenant beaucoup de graines ($\ge 6$). Ces trous représentent un potentiel de gain futur important (Kro ou Grenier) et sont valorisés.

\subsubsection{7. Trous Actifs (Début de Partie)}
En début de jeu, nous favorisons les trous ayant entre 2 et 10 graines. Cela encourage l'IA à développer son jeu et à ne pas laisser de trous morts (0 ou 1 graine) ou trop chargés trop tôt.

\subsubsection{8. Gestion de la Famine et Seuils}
\begin{itemize}
    \item \textbf{Anti-Famine :} Pénalité massive (-400) si nous avons trop peu de graines (< 5) alors que l'adversaire en a beaucoup.
    \item \textbf{Seuils de Victoire :} Bonus progressif si nous approchons des 49 points (seuil de victoire absolue).
\end{itemize}

\section{Architecture de l'IA}

Notre approche combine des concepts fondamentaux vus en cours avec des techniques avancées issues de la littérature sur la programmation des jeux (Game Programming Patterns).

\subsection{Algorithme de Recherche : Negamax Alpha-Beta \textit{(Vu en Cours)}}
Nous utilisons l'algorithme \textbf{Negamax}, une variante simplifiée du Minimax, couplé à l'élagage \textbf{Alpha-Beta}. Ces deux concepts, étudiés en cours, permettent de parcourir l'arbre de jeu efficacement. :
\begin{itemize}
    \item \textbf{Negamax} simplifie l'implémentation en traitant les deux joueurs de manière symétrique ($max(a, b) = -min(-a, -b)$).
    \item \textbf{Alpha-Beta} coupe les branches inutiles (celles que l'adversaire rationnel ne nous laissera jamais jouer), permettant d'explorer plus profondément.
\end{itemize}

\subsection{Optimisations Standards \textit{(Vues en Cours)}}

\subsubsection{1. Iterative Deepening (Approfondissement Itératif)}
Cette technique, également abordée en cours (IDDFS), est cruciale pour la gestion du temps (Time Management).
Au lieu de lancer une recherche à une profondeur fixe (ex: 10) au risque de dépasser le temps limite, nous lançons des recherches successives à profondeur progressive (1, 2, 3...).
Si le temps est écoulé (timeout), nous renvoyons immédiatement le meilleur coup trouvé à l'itération précédente complète.

\subsubsection{2. Table de Transposition}
Pour éviter de recalculer des positions identiques atteintes par des ordres de coups différents (transpositions), nous stockons les résultats dans une Table de Transposition (concept vu en cours).
Cela nous permet de :
\begin{enumerate}
    \item Récupérer instantanément l'évaluation d'une position déjà vue.
    \item Améliorer l'ordre des coups (Move Ordering) en essayant le meilleur coup mémorisé en premier.
\end{enumerate}

\subsection{Optimisations Avancées \textit{(Enrichissements Personnels)}}
Pour atteindre un niveau compétitif, nous avons implémenté des structures de données et des algorithmes issus de la littérature spécialisée.

\subsubsection{1. Zobrist Hashing \& Générateur Xorshift}
La gestion efficace de la Table de Transposition repose sur deux composants :
\begin{itemize}
    \item \textbf{Zobrist Hashing} \cite{zobrist} : Permet de calculer une signature unique (Hash 64 bits) du plateau en temps constant $O(1)$ grâce à des opérations XOR incrémentales.
    \item \textbf{Xorshift64} \cite{xorshift} : Pour initialiser les clés de Zobrist, nous utilisons un générateur de nombres pseudo-aléatoires (PRNG) de type Xorshift. Il est extrêmement rapide et suffisant pour éviter les collisions de hachage dans notre contexte.
\end{itemize}

\subsubsection{2. Null Move Pruning (NMP)}
Cette heuristique consiste à laisser l'adversaire jouer deux fois. Si notre position reste "trop bonne" (beta-cutoff) même sans jouer, on considère que notre position est gagnante et on coupe la recherche. Cela permet un gain de profondeur significatif.

\subsubsection{3. Late Move Reduction (LMR)}
Technique moderne consistant à réduire la profondeur de recherche pour les coups jugés moins prometteurs (ceux triés en fin de liste). Cela permet de concentrer les ressources de calcul sur les variantes principales.

\subsection{Tri des Coups (Move Ordering)}
L'efficacité de l'Alpha-Beta dépend de l'ordre dans lequel on explore les coups. Nous trions les coups dans cet ordre :
\begin{enumerate}
    \item \textbf{Coup de la Table de Transposition :} Le meilleur coup trouvé lors d'une recherche précédente.
    \item \textbf{Captures :} HEURISTIQUE GLOUTONNE.
    \item \textbf{Killer Moves :} Coups ayant provoqué une coupure ailleurs à la même profondeur.
    \item \textbf{Historique :} Coups statistiquement bons.
\end{enumerate}

\section{Conclusion}
En combinant les acquis du cours (Negamax, Alpha-Beta, Table de Transposition) avec des techniques avancées (Zobrist, NMP, LMR) et une fonction d'évaluation riche (8 paramètres), nous avons construit une IA capable de calculer à grande profondeur (12-15 coups) en moins de 2 secondes.

\begin{thebibliography}{9}

\bibitem{zobrist}
Wikipedia, \textit{Fonction de hachage de Zobrist}. \\
\url{https://fr.wikipedia.org/wiki/Fonction_de_hachage_de_Zobrist}

\bibitem{xorshift}
Wikipedia, \textit{Xorshift RNGs}. \\
\url{https://en.wikipedia.org/wiki/Xorshift}

\bibitem{cours_ai}
Jean-Charles Régin, \textit{Cours AI Game Programming}, Master 1 Informatique, Université Côte d'Azur.

\end{thebibliography}

\end{document}
